import ase
import numpy as np
import networkx as nx
import sys
name = sys.argv[1]

N_ATOMS=10
BOXL=200.0 # box edge length in nm
cutoff=0.15
mindist=0.08
positions = np.zeros((N_ATOMS,3))

edges_filename = sys.argv[1]
# load edges
def load_MST_edges(filename):
    G = nx.Graph()
    with open(filename) as f:
        lines = f.readlines()
    for line in lines:
        nodes = line.strip().split(",")
        G.add_edge(int(nodes[0])-1, int(nodes[1])-1)
    return G
    
# initialize positions
for i in range(3):
    positions[0][i] = BOXL/2

# write position out to a gro file
def write_positions(filename, positions):
    gro = open(filename, "w")
    gro.write("Gro Generated by MST_to_gro.py\n")
    gro.write("   %s\n"%N_ATOMS)
    for i in range(N_ATOMS):
        gro.write('%5d%-5s%5s%5d%8.3f%8.3f%8.3f\n'%(i+1, "H", "Ar", i+1, positions[i][0], positions[i][1], positions[i][2]))
    gro.write(" %f %f %f\n"%(BOXL, BOXL, BOXL))
    gro.close()

def check_collapse(index):
    collapse=False
    for i in range(N_ATOMS):
        if i == index:
            pass
        elif compute_distance(index, i) < mindist:
            collapse=True
            return collapse
    return collapse

def compute_distance(a, b):
    return np.linalg.norm((positions[a] - positions[b]))

def check_collapse_all():
    for i in range(N_ATOMS):
        for j in range(i+1, N_ATOMS):
            if compute_distance(i,j) < mindist:
                return True
    return False

# construct current graph
def construct_current_graph():
    G = nx.Graph()
    G.add_nodes_from(list(range(N_ATOMS)))
    for i in range(N_ATOMS):
        for j in range(i+1, N_ATOMS):
            distance = compute_distance(i, j)
            if distance < cutoff:
                G.add_edge(i, j)
    return G

G = load_MST_edges(edges_filename)
edges_ordered = list(nx.dfs_edges(G))
included_atoms = set()
for edge in edges_ordered:
    if edge[1] in included_atoms:
        source = edge[1]
        target = edge[0]
    else:
        source = edge[0]
        target = edge[1]
    while(True):
        phi = np.random.uniform(0, 2*np.pi)  # Azimuthal angle
        costheta = np.random.uniform(-1, 1)   # Cosine of polar angle (theta)
        r = np.random.uniform(mindist, cutoff)   # Distance

        # Convert spherical coordinates to Cartesian coordinates
        theta = np.arccos(costheta)          # Polar angle (theta)
        positions[target][0] = positions[source][0] + r * np.sin(theta) * np.cos(phi)
        positions[target][1] = positions[source][1] + r * np.sin(theta) * np.sin(phi)
        positions[target][2] = positions[source][2] + r * np.cos(theta)
        if check_collapse(target):
            continue
        else:
            break
    included_atoms.add(source)
    included_atoms.add(target)

G = construct_current_graph()
if not check_collapse_all() and nx.algorithms.components.is_connected(G):
    output_filename = sys.argv[2]
    write_positions(output_filename, positions)
else:
    print("%s fails"%(edges_filename))
